"""
Evaluation module for the AgentForge OSS framework.
This module provides tools for agent tracing and evaluation.
"""

import logging
from typing import Dict, List, Any, Optional, Union

from ..core.agent_types import TracerConfig, LLMConfig

logger = logging.getLogger(__name__)

def get_tracer(config: TracerConfig) -> 'BaseTracer':
    """Factory function to get an appropriate tracer"""
    tracer_type = config.extra_params.get("tracer_type", "local")
    
    if tracer_type == "mlflow":
        from .mlflow_tracer import MLflowTracer
        return MLflowTracer(config)
    elif tracer_type == "langsmith":
        from .langsmith_tracer import LangSmithTracer
        return LangSmithTracer(config)
    else:
        from .local_tracer import LocalTracer
        return LocalTracer(config)

class BaseTracer:
    """Base class for agent tracers"""
    
    def __init__(self, config: TracerConfig):
        """Initialize the tracer with a configuration"""
        self.config = config
        self.enabled = config.enabled
        self.current_trace = None
    
    def start_trace(self, task: Any) -> None:
        """
        Start a new trace for a task.
        
        Args:
            task: The task being traced
        """
        if not self.enabled:
            return
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def end_trace(self) -> None:
        """End the current trace"""
        if not self.enabled or self.current_trace is None:
            return
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def log_model_selection(self, model_config: LLMConfig, reason: str) -> None:
        """
        Log model selection information.
        
        Args:
            model_config: The selected model configuration
            reason: The reason for selecting this model
        """
        if not self.enabled or self.current_trace is None:
            return
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def log_plan(self, plan: Dict[str, Any]) -> None:
        """
        Log a plan generated by the agent.
        
        Args:
            plan: The agent's plan
        """
        if not self.enabled or self.current_trace is None:
            return
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def log_tool_start(self, tool_name: str, tool_input: Any) -> None:
        """
        Log the start of a tool execution.
        
        Args:
            tool_name: The name of the tool
            tool_input: The input to the tool
        """
        if not self.enabled or self.current_trace is None:
            return
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def log_tool_end(self, tool_name: str, tool_output: Any) -> None:
        """
        Log the end of a tool execution.
        
        Args:
            tool_name: The name of the tool
            tool_output: The output from the tool
        """
        if not self.enabled or self.current_trace is None:
            return
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def log_error(self, error: Union[str, Exception]) -> None:
        """
        Log an error that occurred during agent execution.
        
        Args:
            error: The error that occurred
        """
        if not self.enabled or self.current_trace is None:
            return
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_traces(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get recent traces.
        
        Args:
            limit: The maximum number of traces to return
            
        Returns:
            A list of traces
        """
        if not self.enabled:
            return []
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_trace(self, trace_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific trace by ID.
        
        Args:
            trace_id: The ID of the trace to retrieve
            
        Returns:
            The trace, or None if not found
        """
        if not self.enabled:
            return None
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def export_trace(self, trace_id: str, format: str = "json") -> Any:
        """
        Export a trace in a specific format.
        
        Args:
            trace_id: The ID of the trace to export
            format: The format to export in (e.g., "json", "html", "markdown")
            
        Returns:
            The exported trace
        """
        if not self.enabled:
            return None
        
        raise NotImplementedError("Subclasses must implement this method")
    
    def compare_traces(self, trace_ids: List[str]) -> Dict[str, Any]:
        """
        Compare multiple traces.
        
        Args:
            trace_ids: The IDs of the traces to compare
            
        Returns:
            A comparison of the traces
        """
        if not self.enabled:
            return {}
        
        raise NotImplementedError("Subclasses must implement this method") 